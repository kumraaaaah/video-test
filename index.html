<!doctype html>

<html>



<head>

    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>

    

    <script>

   AFRAME.registerComponent('ar-video-player', {
    init: function () {
        // --- 1. SETUP ---
        this.videoSources = [
            'assets/@KRSNAOfficial - No Cap (Live Performance Video)_2.mp4',
            'assets/ezgif-512a1a0aa7266c.mp4'
        ];
        this.currentIndex = 0;
        
        // Get all elements safely from the scene or this component's children
        this.marker = this.el.sceneEl.querySelector("a-marker");
        this.videoAsset = this.el.sceneEl.querySelector("#vid");
        this.videoEntity = this.el.querySelector("#ar-video");
        this.nextButton = this.el.querySelector("#next-button");
        this.prevButton = this.el.querySelector("#prev-button");
        this.target = this.videoEntity.object3D;

        this.touchState = {
            isOneFingerRotating: false, isTwoFingerManipulating: false,
            startDist: 0, startAngle: 0, startScale: new THREE.Vector3(),
            startRotation: new THREE.Euler(), lastPanPos: { x: 0, y: 0 },
            lastRotatePos: { x: 0, y: 0 }, touchStartTime: 0,
            startTouchPos: { x: 0, y: 0 }
        };

        // Bind all 'this' contexts
        this.onMarkerFound = this.onMarkerFound.bind(this);
        this.onNext = this.onNext.bind(this);
        this.onPrev = this.onPrev.bind(this);
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);

        // --- 2. ADD EVENT LISTENERS ---
        this.marker.addEventListener('markerFound', this.onMarkerFound);
        this.nextButton.addEventListener('click', this.onNext);
        this.prevButton.addEventListener('click', this.onPrev);
        this.videoEntity.addEventListener('touchstart', this.handleTouchStart);

        // Set initial video
        this.videoAsset.setAttribute('src', this.videoSources[this.currentIndex]);
    },

    onMarkerFound: function () {
        this.el.setAttribute('visible', 'true');
        this.videoAsset.play();
    },
    
    // --- Carousel Logic ---
    onNext: function () {
        this.currentIndex = (this.currentIndex + 1) % this.videoSources.length;
        this.loadVideo();
    },
    onPrev: function () {
        this.currentIndex = (this.currentIndex - 1 + this.videoSources.length) % this.videoSources.length;
        this.loadVideo();
    },
    loadVideo: function () {
        this.videoAsset.setAttribute('src', this.videoSources[this.currentIndex]);
        this.videoAsset.load();
        this.videoAsset.play();
    },

    // --- Manipulation Logic ---
    handleTouchStart: function (evt) {
        this.el.sceneEl.addEventListener('touchmove', this.handleTouchMove);
        this.el.sceneEl.addEventListener('touchend', this.handleTouchEnd);
        const touches = evt.detail.event.touches;
        if (touches.length === 1) {
            this.touchState.isOneFingerRotating = true;
            this.touchState.lastRotatePos = { x: touches[0].clientX, y: touches[0].clientY };
            this.touchState.touchStartTime = evt.timeStamp;
            this.touchState.startTouchPos = { x: touches[0].clientX, y: touches[0].clientY };
        } else if (touches.length === 2) {
            this.touchState.isTwoFingerManipulating = true;
            const t0 = touches[0]; const t1 = touches[1];
            const dx = t0.clientX - t1.clientX; const dy = t0.clientY - t1.clientY;
            this.touchState.startDist = Math.sqrt(dx * dx + dy * dy);
            this.touchState.startAngle = Math.atan2(dy, dx);
            this.touchState.startScale.copy(this.target.scale);
            this.touchState.startRotation.copy(this.target.rotation);
            this.touchState.lastPanPos = { x: (t0.clientX + t1.clientX) / 2, y: (t0.clientY + t1.clientY) / 2 };
        }
    },
    handleTouchMove: function (evt) {
        const touches = evt.touches;
        if (this.touchState.isOneFingerRotating && touches.length === 1) {
            const currentPos = { x: touches[0].clientX, y: touches[0].clientY };
            const deltaX = currentPos.x - this.touchState.lastRotatePos.x;
            const deltaY = currentPos.y - this.touchState.lastRotatePos.y;
            this.target.rotation.y += deltaX * 0.01;
            this.target.rotation.x += deltaY * 0.01;
            this.touchState.lastRotatePos = currentPos;
        }
        if (this.touchState.isTwoFingerManipulating && touches.length === 2) {
            const t0 = touches[0]; const t1 = touches[1];
            const dx = t0.clientX - t1.clientX; const dy = t0.clientY - t1.clientY;
            const currentPanPos = { x: (t0.clientX + t1.clientX) / 2, y: (t0.clientY + t1.clientY) / 2 };
            const panDeltaX = currentPanPos.x - this.touchState.lastPanPos.x;
            const panDeltaY = currentPanPos.y - this.touchState.lastPanPos.y;
            this.target.position.x += panDeltaX * 0.005;
            this.target.position.y -= panDeltaY * 0.005;
            this.touchState.lastPanPos = currentPanPos;
            const currentDist = Math.sqrt(dx * dx + dy * dy);
            const scaleFactor = currentDist / this.touchState.startDist;
            this.target.scale.copy(this.touchState.startScale).multiplyScalar(scaleFactor);
            const currentAngle = Math.atan2(dy, dx);
            const deltaAngle = currentAngle - this.touchState.startAngle;
            this.target.rotation.z = this.touchState.startRotation.z - deltaAngle;
        }
    },
    handleTouchEnd: function (evt) {
        this.el.sceneEl.removeEventListener('touchmove', this.handleTouchMove);
        this.el.sceneEl.removeEventListener('touchend', this.handleTouchEnd);
        if (this.touchState.isOneFingerRotating) {
            const changedTouches = evt.changedTouches;
            const duration = evt.timeStamp - this.touchState.touchStartTime;
            const dx = changedTouches[0].clientX - this.touchState.startTouchPos.x;
            const dy = changedTouches[0].clientY - this.touchState.startTouchPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (duration < 200 && dist < 10) {
                this.videoAsset.muted = !this.videoAsset.muted;
            }
        }
        this.touchState.isOneFingerRotating = false;
        this.touchState.isTwoFingerManipulating = false;
    }
});

    </script>

</head>



<body style="margin: 0; overflow: hidden;">



    <a-scene vr-mode-ui="enabled: false" loading-screen="enabled: false;"

        arjs='sourceType: webcam; trackingMethod: best; debugUIEnabled: false;' 

        id="scene" embedded scene-manager>



        <a-assets>

            <video id="vid" preload="auto" response-type="arraybuffer" loop crossorigin

                webkit-playsinline muted playsinline></video>

        </a-assets>



        <a-marker type="pattern" preset="custom" url="assets/marker.patt"></a-marker>

        

        <a-entity camera raycaster="objects: [screen-manipulator], .clickable;">

            

            <a-entity id="carousel-rig" video-carousel visible="false">

                

                <a-video id="ar-video" src="#vid" scale="0.8 0.8 0.8" position="0 0 -2" rotation="0 0 0" 

                    screen-manipulator></a-video>



                <a-triangle id="next-button" class="clickable" color="#222" scale="0.1 0.1 0.1" position="0.6 0 -1.99" opacity="0.6" rotation="0 0 -90"></a-triangle>



                <a-triangle id="prev-button" class="clickable" color="#222" scale="0.1 0.1 0.1" position="-0.6 0 -1.99" opacity="0.6" rotation="0 0 90"></a-triangle>



            </a-entity>



        </a-entity>



    </a-scene>

</body>

</html>
